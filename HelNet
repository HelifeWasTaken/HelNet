#pragma once

#include <boost/asio.hpp>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <memory>
#include <utility>
#include <chrono>
#include <optional>

namespace helnet
{
    class CountdownTimer
    {
    public:
        using chrono_t = std::chrono;
        using clock_type_t = chrono_t::system_clock;
        using duration_type_t = chrono_t::milliseconds;
        using duration_cast_t = chrono_t::duration_cast<duration_type_t>;

    private:
        mutable double m_time_left;
        mutable std::chrono::time_point<ClockType> m_start_time;

    public:
        // Construct a timer with a given time left
        CountdownTimer(double milliseconds)
            : m_time_left(milliseconds)
            , m_start_time(ClockType::now())
        {
        }

        // Returns the time left in milliseconds
        double time_left() const
        {
            auto now = clock_type_t::now();
            auto elapsed = duration_cast_t(now - m_start_time).count();
            m_time_left -= elapsed;
            m_start_time = now;
            return m_time_left;
        }

        // Returns true if the timer has expired
        bool is_expired() const
        {
            return time_left() <= 0.0f;
        }
    };

    template<typename T, typename Algorithm, typename Container>
    class sorted_list
    {
    public:
        using size_type = std::size_t;
        using value_type = T;
        using reference = T&;
        using pointer = T*;
        using container = Container<T>;
        using iterator = container::iterator;

    private:
        container m_data;

    public:
        sorted_vector() = default;

        // Returns the size of the vector
        size_type size() const
        {
            return m_data.size();
        }

        // Returns true if the vector is empty
        bool empty() const
        {
            return m_data.empty();
        }

        // Returns an iterator to the beginning of the vector
        iterator begin()
        {
            return m_data.begin();
        }

        // Returns an iterator to the end of the vector
        iterator end()
        {
            return m_data.end();
        }

        // Returns a const iterator to the beginning of the vector
        const iterator begin() const
        {
            return m_data.begin();
        }

        // Returns a const iterator to the end of the vector
        const iterator end() const
        {
            return m_data.end();
        }

        // Returns a reference to the element at the given index
        reference at(size_type index)
        {
            return m_data.at(index);
        }

        // Returns a const reference to the element at the given index
        const reference at(size_type index) const
        {
            return m_data.at(index);
        }

        // Adds an element to the vector
        void add(const value_type& value)
        {
            auto it = Algorithm(m_data.begin(), m_data.end(), value);
            m_data.insert(it, value);
        }

        // Adds an element to the vector (with move semantics)
        void add(value_type&& value)
        {
            auto it = Algorithm(m_data.begin(), m_data.end(), value);
            m_data.insert(it, std::move(value));
        }

        // Removes an element from the vector
        bool remove(const value_type& value)
        {
            auto it = Algorithm(m_data.begin(), m_data.end(), value);
            if (it != m_data.end() && *it == value)
            {
                m_data.erase(it);
                return true;
            }
            return false;
        }

        // Removes all elements that match the given value
        void remove(const reference value)
        {
            auto it = Algorithm(m_data.begin(), m_data.end(), value);
            while (it != m_data.end() && *it == value)
            {
                it = m_data.erase(it);
            }
        }

        // Removes an element from the vector at the given index
        void remove_at(size_type index)
        {
            m_data.erase(m_data.begin() + index);
        }

        // Removes all elements from the vector
        void clear()
        {
            m_data.clear();
        }
    };

    template<typename T>
    using basic_sorted_vector = sorted_list<T, std::lower_bound, std::vector>;

    template<typename T, typename Container = std::vector>
    class async_sparse_array
    {
    public:
        using size_type = std::size_t;
        using value_type = std::optional<T>;
        using reference = value_type&;
        using pointer = value_type*;
        using container = Container<value_type>;
        using iterator = container::iterator;

        static constexpr size_type exception_value = static_cast<size_type>(-1);
        static constexpr size_type invalid_index = exception_value;
        static constexpr size_type infinite_size = exception_value;

    private:
        Container m_data;
        std::mutex m_mutex;
        size_type m_max_size;

        basic_sorted_vector<size_type> m_free_indices;

        // to avoid having to iterate through the whole array to find the biggest used index
        size_type m_biggest_used_index = invalid_index;

        // Resizes the array to the given size
        void _resize(size_type size)
        {
            // Do not allow the array to shrink
            if (size < m_data.size())
            {
                return;
            }
            m_data.resize(size);
        }

    public:
        async_sparse_array(size_type max_size = infinite_size)
            : m_max_size(size)
        {
            if (m_max_size != infinite_size)
            {
                m_free_indices.reserve(m_max_size);
                _resize(m_max_size);
            }
            else if (m_max_size <= 1)
            {
                throw std::invalid_argument("max_size must be greater than 1");
            }
        }

        // Returns the size of the array
        size_type size() const
        {
            return m_data.size();
        }

        // Returns true if the array is empty
        bool empty() const
        {
            return m_data.empty();
        }

    private:
        // avoid duplicate code in insert and insert
        // returns the index of where to insert the element
        // returns invalid_index if the array is full
        size_type _insert()
        {
            size_type index = invalid_index;
            if (m_free_indices.empty())
            {
                // The array is full and cannot be resized
                if (m_max_size != infinite_size && m_biggest_used_index == m_max_size - 1)
                    return invalid_index;
                // The array is empty
                else if (m_biggest_used_index == invalid_index) 
                    index = 0;
                // There is a free index after the biggest used index
                else if (m_biggest_used_index < m_data.size() - 1) 
                    index = m_biggest_used_index + 1;
                // There is no free index after the biggest used index so we need to resize the array
                else 
                {
                    index = m_data.size();
                    _resize(index + index / 2 + 1); // resize to 1.5x the current size
                }
            }
            else // There are free indices
            {
                index = m_free_indices.back();
                m_free_indices.remove_at(m_free_indices.size() - 1);
            }
            // Update the biggest used index
            if (index > biggest_used_index || biggest_used_index == invalid_index)
                biggest_used_index = index;
            return index;
        }

    public:
        // inserts an element into the array
        size_type insert(const value_type& value)
        {
            std::unique_lock<std::mutex> lock(m_mutex);
            size_type index = _insert();
            if (index == invalid_index)
            {
                return invalid_index;
            }
            m_data[index] = value;
            return index;
        }

        // inserts an element into the array (with move semantics)
        size_type insert(value_type&& value)
        {
            std::unique_lock<std::mutex> lock(m_mutex);
            size_type index = _insert();
            if (index == invalid_index)
            {
                return invalid_index;
            }
            m_data[index] = std::move(value);
            return index;
        }

        // remove an element from the array
        bool remove(size_type index)
        {
            std::unique_lock<std::mutex> lock(m_mutex);
            if (index >= m_data.size())
            {
                return false;
            }
            m_data[index].reset();
            m_free_indices.add(index);
            return true;
        }

        // remove all elements from the array
        void clear()
        {
            std::unique_lock<std::mutex> lock(m_mutex);
            m_data.clear();
            m_free_indices.clear();
            m_biggest_used_index = invalid_index;
        }

        // Returns a copy of the element at the given index
        value_type copy_get(size_type index)
        {
            std::unique_lock<std::mutex> lock(m_mutex);
            if (index >= m_data.size())
            {
                return std::nullopt;
            }
            return m_data[index];
        }

        // Returns a copy of the element at the given index (const)
        const value_type copy_get(size_type index) const
        {
            std::unique_lock<std::mutex> lock(m_mutex);
            if (index >= m_data.size())
            {
                return std::nullopt;
            }
            return m_data[index];
        }

        // Returns a reference to the element at the given index
        // Throws std::out_of_range if the index is out of range
        // This function is not thread safe as it returns a reference to the element in the array
        // If the element is removed from the array while the reference is still being used, the behavior is undefined
        // Use copy_get instead if you need thread safety
        // (copy_get will always be slower than ref_get but should be good when T is a small type or a shared_ptr)
        reference ref_get(size_type index)
        {
            std::unique_lock<std::mutex> lock(m_mutex);
            if (index >= m_data.size())
            {
                throw std::out_of_range("index out of range");
            }
            return m_data[index];
        }

        // Returns a reference to the element at the given index (const)
        // (see ref_get for more info)
        const reference ref_get(size_type index) const
        {
            std::unique_lock<std::mutex> lock(m_mutex);
            if (index >= m_data.size())
            {
                throw std::out_of_range("index out of range");
            }
            return m_data[index];
        }

        // Tests whether the array contains an element at the given index
        // Returns true if the array contains an element at the given index
        // Returns false if the array does not contain an element at the given index
        // Note: this function is not thread safe as the array may be modified after the call to contains
        // but the function may be used for optimization purposes
        bool contains(size_type index) const
        {
            std::unique_lock<std::mutex> lock(m_mutex);
            if (index >= m_data.size())
            {
                return false;
            }
            return m_data[index].has_value();
        }

        class Iterator
        {
        private:
            async_sparse_array<T, Container>& container;
            size_type index;

        public:
            using value_type = std::pair<size_type, value_type&>;

            Iterator(async_sparse_array<T, Container>& container, size_type index)
                : container(container)
                , index(index)
            {
                if (index < container.end().get_index() && !container.contains(index))
                    ++(*this);
            }

            Iterator& operator++()
            {
                while (++index < container.end().get_index() && !container.contains(index));
                return *this;
            }

            bool operator==(const Iterator& rhs) const
            { return index == rhs.index; }

            bool operator!=(const Iterator& rhs) const
            { return index != rhs.index; }

            bool operator<(const Iterator& rhs) const
            { return index < rhs.index; }

            bool operator>(const Iterator& rhs) const
            { return index > rhs.index; }

            bool operator<=(const Iterator& rhs) const
            { return index <= rhs.index; }

            bool operator>=(const Iterator& rhs) const
            { return index >= rhs.index; }

            const value_type operator*() const
            {
                return { index, container.ref_get(index) };
            }

            value_type operator*()
            {
                return { index, container.ref_get(index) };
            }

            operator bool() const
            {
                return index_valid() && value_valid();
            }

            bool index_valid() const
            {
                return index < container.end().get_index();
            }

            bool value_valid() const
            {
                return index_valid() && container.contains(index);
            }

            size_type get_index() const
            {
                return index;
            }
        };

        // Returns an iterator to the first element in the array
        // This iterator is not thread safe as it takes a reference to the array
        // If the array is modified while the iterator is being used, the behavior is undefined
        // If you want to use it make sure to that nobody can modify the array while the iterator is being used
        Iterator begin()
        {
            return Iterator(*this, 0);
        }

        // Returns an iterator to the element following the last element in the array
        // This iterator is not thread safe as it takes a reference to the array
        // If the array is modified while the iterator is being used, the behavior is undefined
        // If you want to use it make sure to that nobody can modify the array while the iterator is being used
        Iterator end()
        {
            return Iterator(*this, m_biggest_used_index + 1);
        }
    };

    template<typename T>
    using basic_async_sparse_array = basic_async_sparse_array<T, std::vector>;
}
