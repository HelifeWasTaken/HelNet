#pragma once

#include <boost/asio.hpp>
#include <boost/endian/conversion.hpp>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <memory>
#include <utility>
#include <chrono>
#include <optional>

namespace helnet
{
    class CountdownTimer
    {
    public:
        using chrono_t = std::chrono;
        using clock_type_t = chrono_t::system_clock;
        using duration_type_t = chrono_t::milliseconds;
        using duration_cast_t = chrono_t::duration_cast<duration_type_t>;

    private:
        mutable double m_time_left;
        mutable std::chrono::time_point<ClockType> m_start_time;

    public:
        // Construct a timer with a given time left
        CountdownTimer(double milliseconds)
            : m_time_left(milliseconds)
            , m_start_time(ClockType::now())
        {
        }

        // Returns the time left in milliseconds
        double time_left() const
        {
            auto now = clock_type_t::now();
            auto elapsed = duration_cast_t(now - m_start_time).count();
            m_time_left -= elapsed;
            m_start_time = now;
            return m_time_left;
        }

        // Returns true if the timer has expired
        bool is_expired() const
        {
            return time_left() <= 0.0f;
        }
    };

    template<typename T, typename Algorithm, typename Container>
    class sorted_list
    {
    public:
        using size_type = std::size_t;
        using value_type = T;
        using reference = T&;
        using pointer = T*;
        using container = Container<T>;
        using iterator = container::iterator;

    private:
        container m_data;

    public:
        sorted_vector() = default;

        // Returns the size of the vector
        size_type size() const
        {
            return m_data.size();
        }

        // Returns true if the vector is empty
        bool empty() const
        {
            return m_data.empty();
        }

        // Returns an iterator to the beginning of the vector
        iterator begin()
        {
            return m_data.begin();
        }

        // Returns an iterator to the end of the vector
        iterator end()
        {
            return m_data.end();
        }

        // Returns a const iterator to the beginning of the vector
        const iterator begin() const
        {
            return m_data.begin();
        }

        // Returns a const iterator to the end of the vector
        const iterator end() const
        {
            return m_data.end();
        }

        // Returns a reference to the element at the given index
        reference at(size_type index)
        {
            return m_data.at(index);
        }

        // Returns a const reference to the element at the given index
        const reference at(size_type index) const
        {
            return m_data.at(index);
        }

        // Adds an element to the vector
        void add(const value_type& value)
        {
            auto it = Algorithm(m_data.begin(), m_data.end(), value);
            m_data.insert(it, value);
        }

        // Adds an element to the vector (with move semantics)
        void add(value_type&& value)
        {
            auto it = Algorithm(m_data.begin(), m_data.end(), value);
            m_data.insert(it, std::move(value));
        }

        // Removes an element from the vector
        bool remove(const value_type& value)
        {
            auto it = Algorithm(m_data.begin(), m_data.end(), value);
            if (it != m_data.end() && *it == value)
            {
                m_data.erase(it);
                return true;
            }
            return false;
        }

        // Removes all elements that match the given value
        void remove(const reference value)
        {
            auto it = Algorithm(m_data.begin(), m_data.end(), value);
            while (it != m_data.end() && *it == value)
            {
                it = m_data.erase(it);
            }
        }

        // Removes an element from the vector at the given index
        void remove_at(size_type index)
        {
            m_data.erase(m_data.begin() + index);
        }

        // Removes all elements from the vector
        void clear()
        {
            m_data.clear();
        }
    };

    template<typename T>
    using basic_sorted_vector = sorted_list<T, std::lower_bound, std::vector>;

    template<typename T, typename Container = std::vector>
    class async_sparse_array
    {
    public:
        using size_type = std::size_t;
        using value_type = std::optional<T>;
        using reference = value_type&;
        using pointer = value_type*;
        using container = Container<value_type>;
        using iterator = container::iterator;

        static constexpr size_type exception_value = static_cast<size_type>(-1);
        static constexpr size_type invalid_index = exception_value;
        static constexpr size_type infinite_size = exception_value;

    private:
        Container m_data;
        std::mutex m_mutex;
        size_type m_max_size;

        basic_sorted_vector<size_type> m_free_indices;

        // to avoid having to iterate through the whole array to find the biggest used index
        size_type m_biggest_used_index = invalid_index;

        // Resizes the array to the given size
        void _resize(size_type size)
        {
            // Do not allow the array to shrink
            if (size < m_data.size())
            {
                return;
            }
            m_data.resize(size);
        }

    public:
        async_sparse_array(size_type max_size = infinite_size)
            : m_max_size(size)
        {
            if (m_max_size != infinite_size)
            {
                m_free_indices.reserve(m_max_size);
                _resize(m_max_size);
            }
            else if (m_max_size <= 1)
            {
                throw std::invalid_argument("max_size must be greater than 1");
            }
        }

        // Returns the size of the array
        size_type size() const
        {
            return m_data.size();
        }

        // Returns true if the array is empty
        bool empty() const
        {
            return m_data.empty();
        }

    private:
        // avoid duplicate code in insert and insert
        // returns the index of where to insert the element
        // returns invalid_index if the array is full
        size_type _insert()
        {
            size_type index = invalid_index;
            if (m_free_indices.empty())
            {
                // The array is full and cannot be resized
                if (m_max_size != infinite_size && m_biggest_used_index == m_max_size - 1)
                    return invalid_index;
                // The array is empty
                else if (m_biggest_used_index == invalid_index) 
                    index = 0;
                // There is a free index after the biggest used index
                else if (m_biggest_used_index < m_data.size() - 1) 
                    index = m_biggest_used_index + 1;
                // There is no free index after the biggest used index so we need to resize the array
                else 
                {
                    index = m_data.size();
                    _resize(index + index / 2 + 1); // resize to 1.5x the current size
                }
            }
            else // There are free indices
            {
                index = m_free_indices.back();
                m_free_indices.remove_at(m_free_indices.size() - 1);
            }
            // Update the biggest used index
            if (index > biggest_used_index || biggest_used_index == invalid_index)
                biggest_used_index = index;
            return index;
        }

    public:
        // inserts an element into the array
        size_type insert(const value_type& value)
        {
            std::unique_lock<std::mutex> lock(m_mutex);
            size_type index = _insert();
            if (index == invalid_index)
            {
                return invalid_index;
            }
            m_data[index] = value;
            return index;
        }

        // inserts an element into the array (with move semantics)
        size_type insert(value_type&& value)
        {
            std::unique_lock<std::mutex> lock(m_mutex);
            size_type index = _insert();
            if (index == invalid_index)
            {
                return invalid_index;
            }
            m_data[index] = std::move(value);
            return index;
        }

        // remove an element from the array
        bool remove(size_type index)
        {
            std::unique_lock<std::mutex> lock(m_mutex);
            if (index >= m_data.size())
            {
                return false;
            }
            m_data[index].reset();
            m_free_indices.add(index);
            return true;
        }

        // remove all elements from the array
        void clear()
        {
            std::unique_lock<std::mutex> lock(m_mutex);
            m_data.clear();
            m_free_indices.clear();
            m_biggest_used_index = invalid_index;
        }

        // Returns a copy of the element at the given index
        value_type copy_get(size_type index)
        {
            std::unique_lock<std::mutex> lock(m_mutex);
            if (index >= m_data.size())
            {
                return std::nullopt;
            }
            return m_data[index];
        }

        // Returns a copy of the element at the given index (const)
        const value_type copy_get(size_type index) const
        {
            std::unique_lock<std::mutex> lock(m_mutex);
            if (index >= m_data.size())
            {
                return std::nullopt;
            }
            return m_data[index];
        }

        // Returns a reference to the element at the given index
        // Throws std::out_of_range if the index is out of range
        // This function is not thread safe as it returns a reference to the element in the array
        // If the element is removed from the array while the reference is still being used, the behavior is undefined
        // Use copy_get instead if you need thread safety
        // (copy_get will always be slower than ref_get but should be good when T is a small type or a shared_ptr)
        reference ref_get(size_type index)
        {
            std::unique_lock<std::mutex> lock(m_mutex);
            if (index >= m_data.size())
            {
                throw std::out_of_range("index out of range");
            }
            return m_data[index];
        }

        // Returns a reference to the element at the given index (const)
        // (see ref_get for more info)
        const reference ref_get(size_type index) const
        {
            std::unique_lock<std::mutex> lock(m_mutex);
            if (index >= m_data.size())
            {
                throw std::out_of_range("index out of range");
            }
            return m_data[index];
        }

        // Tests whether the array contains an element at the given index
        // Returns true if the array contains an element at the given index
        // Returns false if the array does not contain an element at the given index
        // Note: this function is not thread safe as the array may be modified after the call to contains
        // but the function may be used for optimization purposes
        bool contains(size_type index) const
        {
            std::unique_lock<std::mutex> lock(m_mutex);
            if (index >= m_data.size())
            {
                return false;
            }
            return m_data[index].has_value();
        }

        class Iterator
        {
        private:
            async_sparse_array<T, Container>& container;
            size_type index;

        public:
            using value_type = std::pair<size_type, value_type&>;

            Iterator(async_sparse_array<T, Container>& container, size_type index)
                : container(container)
                , index(index)
            {
                if (index < container.end().get_index() && !container.contains(index))
                    ++(*this);
            }

            Iterator& operator++()
            {
                while (++index < container.end().get_index() && !container.contains(index));
                return *this;
            }

            bool operator==(const Iterator& rhs) const
            { return index == rhs.index; }

            bool operator!=(const Iterator& rhs) const
            { return index != rhs.index; }

            bool operator<(const Iterator& rhs) const
            { return index < rhs.index; }

            bool operator>(const Iterator& rhs) const
            { return index > rhs.index; }

            bool operator<=(const Iterator& rhs) const
            { return index <= rhs.index; }

            bool operator>=(const Iterator& rhs) const
            { return index >= rhs.index; }

            const value_type operator*() const
            {
                return { index, container.ref_get(index) };
            }

            value_type operator*()
            {
                return { index, container.ref_get(index) };
            }

            operator bool() const
            {
                return index_valid() && value_valid();
            }

            bool index_valid() const
            {
                return index < container.end().get_index();
            }

            bool value_valid() const
            {
                return index_valid() && container.contains(index);
            }

            size_type get_index() const
            {
                return index;
            }
        };

        // Returns an iterator to the first element in the array
        // This iterator is not thread safe as it takes a reference to the array
        // If the array is modified while the iterator is being used, the behavior is undefined
        // If you want to use it make sure to that nobody can modify the array while the iterator is being used
        Iterator begin()
        {
            return Iterator(*this, 0);
        }

        // Returns an iterator to the element following the last element in the array
        // This iterator is not thread safe as it takes a reference to the array
        // If the array is modified while the iterator is being used, the behavior is undefined
        // If you want to use it make sure to that nobody can modify the array while the iterator is being used
        Iterator end()
        {
            return Iterator(*this, m_biggest_used_index + 1);
        }
    };

    template<typename T>
    using basic_async_sparse_array = basic_async_sparse_array<T, std::vector>;

    using byte = uint8_t;

    class type_checker {
    public:
        template<typename T>
        static constexpr bool is_arithmetic_type()
        {
            return std::is_arithmetic_v<T>;
        }

        template<typename T>
        static constexpr bool is_arithmetic_type(const T&)
        {
            return is_arithmetic_type<T>();
        }

        template<typename T>
        static constexpr bool is_enum_type()
        {
            return std::is_enum_v<T>;
        }

        template<typename T>
        static constexpr bool is_enum_type(const T&)
        {
            return is_enum_type<T>();
        }

        template<typename T>
        static constexpr bool is_string_type()
        {
            return std::is_same_v<std::remove_cvref_t<T>, std::string>;
        }

        template<typename T>
        static constexpr bool is_string_type(const T&)
        {
            return is_string_type<T>();
        }

        template<typename T>
        static constexpr bool is_vector_type()
        {
            return std::is_same_v<std::remove_cvref_t<T>, std::vector<typename T::value_type>>;
        }

        template<typename T>
        static constexpr bool is_vector_type(const T&)
        {
            return is_vector_type<T>();
        }

        template<typename T>
        static constexpr bool is_byte_type()
        {
            return std::is_same_v<std::remove_cvref_t<T>, byte>;
        }

        template<typename T>
        static constexpr bool is_byte_type(const T&)
        {
            return is_byte_type<T>();
        }

        template<typename T>
        static constexpr bool is_pointer_type()
        {
            return std::is_pointer_v<T>;
        }

        template<typename T>
        static constexpr bool is_pointer_type(const T&)
        {
            return is_pointer_type<T>();
        }
    };

    // A serializer that can be used to serialize data into a byte array
    // It serializes data in little endian format.
    // It can be used to serialize any type of data.
    // When serializing a type, it must either be a byte array, a string, or arithmetical type (int, float, etc.)
    // You cannot serialize any floating points because they are not normalized.

    // When serializing a vector, it will be serialized as:
    //      A uint64_t representing the size of the vector
    //      The data of the vector
    //      All the data is written with the write function so each element
    //          will be normalized as little endian

    // When serializing a string it will be serialized as:
    //      A uint64_t representing the size of the string
    //      The data of the string

    // The byte array will be considered raw data and nothing will be done to
    // indicate the size of the array. It will be written as is.
    template<typename Container>
    class Serializer
    {
    public:
        using size_type = size_t;
        using container = Container<byte>;
        using slices = std::vector<container>;

    private:
        container m_data;

        // Writes the data to the byte array
        inline void _write_bytes(const byte* data, size_t size)
        {
            m_data.insert(m_data.end(), data, data + size);
        }

        // Writes a string to the byte array
        inline void _write_string(const std::string& data)
        {
            uint64_t size = data.size();
            write(size);
            write_bytes(reinterpret_cast<const byte*>(data.data()), size);
        }

        // Writes a vector to the byte array
        template<typename T>
        inline void _write_vector(const std::vector<T>& data)
        {
            uint64_t size = data.size();
            write(size);
            std::for_each(data.begin(), data.end(), write<T>);
        }

        // Writes an arithmetical type to the byte array
        template<typename T>
        inline void _write_arithmetic(const T& data)
        {
            static_assert(sizeof(T) <= sizeof(byte) * 8, "T is too big to be serialized as a arithmetical type");
            T copy_data = boost::endian::native_to_little(data);
            write_bytes(reinterpret_cast<byte*>(&copy_data), sizeof(T));
        }

    public:
        // Optimizes the memory usage of the byte array
        void reserve(size_type size)
        {
            m_data.reserve(size);
        }

        // Writes data to the byte array using the template parameter
        template<typename T>
        inline void write(const T& data)
        {
            if constexpr (type_checker::is_arithmetic_type(data))
            {
                _write_arithmetic(data);
            }
            else if constexpr (type_checker::is_string_type(data))
            {
                _write_string(data);
            }
            else if constexpr (type_checker::is_vector_type(data))
            {
                _write_vector(data);
            }
            else if constexpr (type_checker::is_byte_type(data))
            {
                _write_bytes(&data, sizeof(data));
            }
            else
            {
                static_assert(false, "T is not a valid type to be serialized");
            }
        }

        // write a sequence of raw bytes to the byte array
        inline void write_bytes(const byte* data, size_type size)
        {
            _write_bytes(data, size);
        }

        // Returns the byte array
        container &bytes()
        {
            return m_data;
        }

        // Returns the byte array (const)
        const container &bytes() const
        {
            return m_data;
        }

        // Return an array of byte array that are splitted into slices of size n
        slices as_slices_of(size_type n) const
        {
            assert(n > 0);
            std::vector<container> slices;
            size_type i = 0;
            while (i < m_data.size())
            {
                slices.push_back(container(m_data.begin() + i, m_data.begin() + std::min(i + size, m_data.size())));
                i += size;
            }
            return slices;
        }

        // Returns the size of the byte array
        size_type size() const
        {
            return m_data.size();
        }

        // Clears the byte array
        void clear()
        {
            m_data.clear();
        }

        // Merges two serializers into one
        static Serializer merge(Serializer a, Serializer b)
        {
            Serializer s;
            s.reserve(a.size() + b.size());
            s.write(a.bytes());
            s.write(b.bytes());
            return s;
        }

        // Add a sequence of bytes every N bytes (can exclud/include the given sequence size)
        // including the sequence size means that the sequence size will be added to the N
        // It can be useful for adding headers to a byte array
        static slices add_sequence_every_n_bytes_and_slice(
            size_type n, Serializer sequence, 
            bool include_sequence_size = true) const
        {
            const container &sbytes = sequence.bytes();
            if (include_sequence_size)
            {
                if (n <= sbytes.size())
                    throw std::invalid_argument("n must be greater than the size of the sequence");
                n -= sbytes.size();
            }

            Serializer s;
            s.reserve(m_data.size() + (m_data.size() / n) * sbytes.size());

            for (size_type i = 0; i < m_data.size(); i += n)
            {
                s.write_bytes(m_data.data() + i, std::min(n, m_data.size() - i));
                if (i + n < m_data.size())
                    s.write_bytes(sbytes);
            }
            return s.as_slices_of(n + (include_sequence_size ? sbytes.size() : 0))
        }

        // Constructor
        Serializer() = default;

        // Destructor
        ~Serializer() = default;
    };

    template<typename TSerializer, typename T>
    static inline TSerializer &operator<<(TSerializer &serializer, const T &data)
    {
        serializer.write(data);
        return serializer;
    }

    using basic_serializer = Serializer<std::vector>;

    // A deserializer that can be used to deserialize data from a byte array
    // It deserializes the data the same way it was serialized (c.f. Serializer)
    template<typename Container>
    class Deserializer
    {
    public:
        using size_type = size_t;

    private:
        byte *m_data;
        size_type m_size;
        byte *m_ptr;
        byte *m_endptr;

        // Reads a sequence of raw bytes for an arithmetical type
        T _read_arithmetic()
        {
            static_assert(sizeof(T) <= sizeof(byte) * 8, "T is too big to be deserialized");

            if (m_ptr + sizeof(T) >= m_endptr)
                throw std::runtime_error("Not enough data to deserialize arithmetical type");
            T data;
            std::memcpy(&data, m_ptr, sizeof(T));
            m_ptr += sizeof(T);
            boost::endian::little_to_native_inplace(data);
            return data;
        }

        // Reads a string
        std::string _read_string()
        {
            size_type size = read<size_type>();
            if (m_ptr + size >= m_endptr)
                throw std::runtime_error("Not enough data to deserialize string");
            std::string str(reinterpret_cast<char *>(m_ptr), size);
            m_ptr += size;
            return str;
        }

        // Reads a vector of arithmetical types or strings
        template<typename T>
        std::vector<T> _read_vector()
        {
            size_type size = read<size_type>();
            std::vector<T> vec;
            vec.reserve(size);
            for (size_type i = 0; i < size; ++i)
                vec.push_back(read<T>());
            return vec;
        }

        // Reads a sequence of raw bytes
        std::vector<byte> _read_bytes(size_type size)
        {
            if (m_ptr + size >= m_endptr)
                throw std::runtime_error("Not enough data to deserialize bytes");
            std::vector<byte> vec(m_ptr, m_ptr + size);
            m_ptr += size;
            return vec;
        }

    public:
        // Constructor
        // data: A pointer to the byte array
        // size: The size of the byte array
        Deserializer(byte *data, size_type size)
            : m_data(data), m_size(size), m_ptr(data), m_endptr(data + size)
        {
        }

        // Reads data from the byte array
        template<typename T>
        T read()
        {
            if constexpr (type_checker::is_arithmetic_type<T>())
            {
                return _read_arithmetic<T>();
            }
            else if constexpr (type_checker::is_string_type<T>())
            {
                return _read_string();
            }
            else if constexpr (type_checker::is_vector_type<T>())
            {
                return _read_vector<typename T::value_type>();
            }
            else
            {
                static_assert(false, "T is not a valid type to be deserialized");
            }
        }

        // Reads a sequence of raw bytes with a given size
        std::vector<byte> read_bytes(size_type size)
        {
            return _read_bytes(size);
        }
    };

    using basic_deserializer = Deserializer<std::vector>;

    // Deserialize any T type deserializable by Deserializer::read<T>()
    template<typename TDeserializer, typename T>
    static inline TDeserializer &operator>>(TDeserializer &deserializer, T &data)
    {
        data = deserializer.read<T>();
        return deserializer;
    }
}
