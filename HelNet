#pragma once

#include <boost/asio.hpp>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <memory>
#include <utility>
#include <chrono>
#include <optional>

namespace helnet
{
    class CountdownTimer
    {
    public:
        using chrono_t = std::chrono;
        using clock_type_t = chrono_t::system_clock;
        using duration_type_t = chrono_t::milliseconds;
        using duration_cast_t = chrono_t::duration_cast<duration_type_t>;

    private:
        mutable double m_time_left;
        mutable std::chrono::time_point<ClockType> m_start_time;

    public:
        // Construct a timer with a given time left
        CountdownTimer(double milliseconds)
            : m_time_left(milliseconds)
            , m_start_time(ClockType::now())
        {
        }

        // Returns the time left in milliseconds
        double time_left() const
        {
            auto now = clock_type_t::now();
            auto elapsed = duration_cast_t(now - m_start_time).count();
            m_time_left -= elapsed;
            m_start_time = now;
            return m_time_left;
        }

        // Returns true if the timer has expired
        bool is_expired() const
        {
            return time_left() <= 0.0f;
        }
    };

    template<typename T, typename Algorithm, typename Container>
    class sorted_list
    {
    public:
        using size_type = std::size_t;
        using value_type = T;
        using reference = T&;
        using pointer = T*;
        using container = Container<T>;
        using iterator = container::iterator;

    private:
        container m_data;

    public:
        sorted_vector() = default;

        // Returns the size of the vector
        size_type size() const
        {
            return m_data.size();
        }

        // Returns true if the vector is empty
        bool empty() const
        {
            return m_data.empty();
        }

        // Returns an iterator to the beginning of the vector
        iterator begin()
        {
            return m_data.begin();
        }

        // Returns an iterator to the end of the vector
        iterator end()
        {
            return m_data.end();
        }

        // Returns a const iterator to the beginning of the vector
        const iterator begin() const
        {
            return m_data.begin();
        }

        // Returns a const iterator to the end of the vector
        const iterator end() const
        {
            return m_data.end();
        }

        // Returns a reference to the element at the given index
        reference at(size_type index)
        {
            return m_data.at(index);
        }

        // Returns a const reference to the element at the given index
        const reference at(size_type index) const
        {
            return m_data.at(index);
        }

        // Adds an element to the vector
        void add(const value_type& value)
        {
            auto it = Algorithm(m_data.begin(), m_data.end(), value);
            m_data.insert(it, value);
        }

        // Adds an element to the vector (with move semantics)
        void add(value_type&& value)
        {
            auto it = Algorithm(m_data.begin(), m_data.end(), value);
            m_data.insert(it, std::move(value));
        }

        // Removes an element from the vector
        bool remove(const value_type& value)
        {
            auto it = Algorithm(m_data.begin(), m_data.end(), value);
            if (it != m_data.end() && *it == value)
            {
                m_data.erase(it);
                return true;
            }
            return false;
        }

        // Removes all elements that match the given value
        void remove(const reference value)
        {
            auto it = Algorithm(m_data.begin(), m_data.end(), value);
            while (it != m_data.end() && *it == value)
            {
                it = m_data.erase(it);
            }
        }

        // Removes an element from the vector at the given index
        void remove_at(size_type index)
        {
            m_data.erase(m_data.begin() + index);
        }

        // Removes all elements from the vector
        void clear()
        {
            m_data.clear();
        }
    };

    template<typename T>
    using basic_sorted_vector = sorted_list<T, std::lower_bound, std::vector>;
}
