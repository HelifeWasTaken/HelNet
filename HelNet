#pragma once

#include <boost/asio.hpp>
#include <boost/endian/conversion.hpp>
#include <boost/system/error_code.hpp>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <memory>
#include <utility>
#include <chrono>
#include <optional>
#include <vector>
#include <atomic>
#include <algorithm>
#include <list>
#include <thread>

namespace helnet
{
    template <typename T>
    using atomic = std::atomic<T>;

    using mutex = std::mutex;

    using condition_variable = std::condition_variable;

    template <typename T>
    using queue = std::queue<T>;

    template <typename T>
    using list = std::list<T>;

    using thread = std::thread;
    namespace this_thread = std::this_thread;

    template <typename M>
    using unique_lock = std::unique_lock<M>;

    template <typename T>
    using vector = std::vector<T>;

    template <typename O>
    using optional = std::optional<O>;

    template <typename F, typename S>
    using pair = std::pair<F, S>;

    using string = std::string;

    template <typename F>
    using function = std::function<F>;

    namespace chrono = std::chrono;

    class CountdownTimer
    {
    public:
        using clock_type_t = chrono::system_clock;
        using duration_type_t = chrono::milliseconds;

    private:
        mutable double m_time_left;
        mutable std::chrono::time_point<clock_type_t> m_start_time;

    public:
        // Construct a timer with a given time left
        CountdownTimer(double milliseconds)
            : m_time_left(milliseconds), m_start_time(clock_type_t::now())
        {
        }

        // Returns the time left in milliseconds
        double time_left() const
        {
            auto now = clock_type_t::now();
            auto elapsed = chrono::duration_cast<duration_type_t>(now - m_start_time).count();
            m_time_left -= elapsed;
            m_start_time = now;
            return m_time_left;
        }

        // Returns true if the timer has expired
        bool is_expired() const
        {
            return time_left() <= 0.0f;
        }
    };

    template <typename T>
    class sorted_vector
    {
    public:
        using size_type_t = size_t;
        using value_type = T;
        using reference_t = T &;
        using pointer_t = T *;
        using container_t = vector<T>;
        using iterator = container_t::iterator;

    private:
        container_t m_data;

    public:
        sorted_vector() = default;

        // Returns the size of the vector
        size_type_t size() const
        {
            return m_data.size();
        }

        // Returns true if the vector is empty
        bool empty() const
        {
            return m_data.empty();
        }

        // Returns an iterator to the beginning of the vector
        iterator begin()
        {
            return m_data.begin();
        }

        // Returns an iterator to the end of the vector
        iterator end()
        {
            return m_data.end();
        }

        // Returns a const iterator to the beginning of the vector
        const iterator begin() const
        {
            return m_data.begin();
        }

        // Returns a const iterator to the end of the vector
        const iterator end() const
        {
            return m_data.end();
        }

        // Returns a reference to the element at the given index
        reference_t at(size_type_t index)
        {
            return m_data.at(index);
        }

        // Returns a const reference to the element at the given index
        const reference_t at(size_type_t index) const
        {
            return m_data.at(index);
        }

        // Adds an element to the vector
        void add(const value_type &value)
        {
            auto it = Algorithm(m_data.begin(), m_data.end(), value);
            m_data.insert(it, value);
        }

        // Adds an element to the vector (with move semantics)
        void add(value_type &&value)
        {
            auto it = Algorithm(m_data.begin(), m_data.end(), value);
            m_data.insert(it, std::move(value));
        }

        // Removes an element from the vector
        bool remove(const value_type &value)
        {
            auto it = Algorithm(m_data.begin(), m_data.end(), value);
            if (it != m_data.end() && *it == value)
            {
                m_data.erase(it);
                return true;
            }
            return false;
        }

        // Removes all elements that match the given value
        void remove(const reference_t value)
        {
            auto it = Algorithm(m_data.begin(), m_data.end(), value);
            while (it != m_data.end() && *it == value)
            {
                it = m_data.erase(it);
            }
        }

        // Removes an element from the vector at the given index
        void remove_at(size_type_t index)
        {
            m_data.erase(m_data.begin() + index);
        }

        // Removes all elements from the vector
        void clear()
        {
            m_data.clear();
        }

        // Reserves memory for the vector
        void reserve(size_type_t size)
        {
            m_data.reserve(size);
        }

        // Returns the back element of the vector
        reference_t back()
        {
            return m_data.back();
        }

        // Returns the front element of the vector
        reference_t front()
        {
            return m_data.front();
        }
    };

    template <typename T>
    class async_sparse_array
    {
    public:
        using size_type_t = size_t;
        using value_type = optional<T>;
        using reference_t = value_type &;
        using pointer_t = value_type *;
        using container_t = vector<optional<T>>;
        using iterator = container_t::iterator;

        static constexpr size_type_t exception_value = static_cast<size_type_t>(std::numeric_limits<size_type_t>::max());
        static constexpr size_type_t invalid_index = exception_value;
        static constexpr size_type_t infinite_size = exception_value;

    private:
        container_t m_data;
        mutex m_mutex;
        size_type_t m_max_size;

        sorted_vector<size_type_t> m_free_indices;

        // to avoid having to iterate through the whole array to find the biggest used index
        size_type_t m_biggest_used_index = invalid_index;

        // Resizes the array to the given size
        void _resize(size_type_t size)
        {
            // Do not allow the array to shrink
            if (size < m_data.size())
            {
                return;
            }
            m_data.resize(size);
        }

    public:
        async_sparse_array(size_type_t max_size = infinite_size)
            : m_max_size(size)
        {
            if (m_max_size != infinite_size)
            {
                m_free_indices.reserve(m_max_size);
                _resize(m_max_size);
            }
            else if (m_max_size <= 1)
            {
                throw std::invalid_argument("max_size must be greater than 1");
            }
        }

        // Returns the size of the array
        size_type_t size() const
        {
            return m_data.size();
        }

        // Returns true if the array is empty
        bool empty() const
        {
            return m_data.empty();
        }

    private:
        // avoid duplicate code in insert and insert
        // returns the index of where to insert the element
        // returns invalid_index if the array is full
        size_type_t _insert()
        {
            size_type_t index = invalid_index;
            if (m_free_indices.empty())
            {
                // The array is full and cannot be resized
                if (m_max_size != infinite_size && m_biggest_used_index == m_max_size - 1)
                    return invalid_index;
                // The array is empty
                else if (m_biggest_used_index == invalid_index)
                    index = 0;
                // There is a free index after the biggest used index
                else if (m_biggest_used_index < m_data.size() - 1)
                    index = m_biggest_used_index + 1;
                // There is no free index after the biggest used index so we need to resize the array
                else
                {
                    index = m_data.size();
                    _resize(index + index / 2 + 1); // resize to 1.5x the current size
                }
            }
            else // There are free indices
            {
                index = m_free_indices.back();
                m_free_indices.remove_at(m_free_indices.size() - 1);
            }
            // Update the biggest used index
            if (index > m_biggest_used_index || m_biggest_used_index == invalid_index)
                m_biggest_used_index = index;
            return index;
        }

    public:
        // inserts an element into the array
        size_type_t insert(const value_type &value)
        {
            unique_lock<mutex> lock(m_mutex);
            size_type_t index = _insert();
            if (index == invalid_index)
            {
                return invalid_index;
            }
            m_data[index] = value;
            return index;
        }

        // inserts an element into the array (with move semantics)
        size_type_t insert(value_type &&value)
        {
            unique_lock<mutex> lock(m_mutex);
            size_type_t index = _insert();
            if (index == invalid_index)
            {
                return invalid_index;
            }
            m_data[index] = std::move(value);
            return index;
        }

        // remove an element from the array
        bool remove(size_type_t index)
        {
            unique_lock<mutex> lock(m_mutex);
            if (index >= m_data.size())
            {
                return false;
            }
            m_data[index].reset();
            m_free_indices.add(index);
            return true;
        }

        // remove all elements from the array
        void clear()
        {
            unique_lock<mutex> lock(m_mutex);
            m_data.clear();
            m_free_indices.clear();
            m_biggest_used_index = invalid_index;
        }

        // Returns a copy of the element at the given index
        value_type copy_get(size_type_t index)
        {
            unique_lock<mutex> lock(m_mutex);
            if (index >= m_data.size())
            {
                return nullptr;
            }
            return m_data[index];
        }

        // Returns a copy of the element at the given index (const)
        const value_type copy_get(size_type_t index) const
        {
            unique_lock<mutex> lock(m_mutex);
            if (index >= m_data.size())
            {
                return nullptr;
            }
            return m_data[index];
        }

        // Returns a reference to the element at the given index
        // This function is not thread safe as it returns a reference to the element in the array
        // If the element is removed from the array while the reference is still being used, the behavior is undefined
        // Use copy_get instead if you need thread safety
        // (copy_get will always be slower than ref_get but should be good when T is a small type or a shared_ptr)
        reference_t ref_get(size_type_t index)
        {
            unique_lock<mutex> lock(m_mutex);
            if (index >= m_data.size())
            {
                throw std::out_of_range("index out of range");
            }
            return m_data[index];
        }

        // Returns a reference to the element at the given index (const)
        // (see ref_get for more info)
        const reference_t ref_get(size_type_t index) const
        {
            unique_lock<mutex> lock(m_mutex);
            if (index >= m_data.size())
            {
                throw std::out_of_range("index out of range");
            }
            return m_data[index];
        }

        // Tests whether the array contains an element at the given index
        // Returns true if the array contains an element at the given index
        // Returns false if the array does not contain an element at the given index
        // Note: this function is not thread safe as the array may be modified after the call to contains
        // but the function may be used for optimization purposes
        bool contains(size_type_t index) const
        {
            unique_lock<mutex> lock(m_mutex);
            if (index >= m_data.size())
            {
                return false;
            }
            return m_data[index].has_value();
        }

        class Iterator
        {
        private:
            async_sparse_array<T> &container;
            size_type_t index;

        public:
            using it_value_type = pair<size_type_t, value_type &>;

            Iterator(async_sparse_array<T> &container, size_type_t index)
                : container_t(container), index(index)
            {
                if (index < container.end().get_index() && !container.contains(index))
                    ++(*this);
            }

            Iterator &operator++()
            {
                while (++index < container.end().get_index() && !container.contains(index))
                    ;
                return *this;
            }

            bool operator==(const Iterator &rhs) const
            {
                return index == rhs.index;
            }

            bool operator!=(const Iterator &rhs) const
            {
                return index != rhs.index;
            }

            bool operator<(const Iterator &rhs) const
            {
                return index < rhs.index;
            }

            bool operator>(const Iterator &rhs) const
            {
                return index > rhs.index;
            }

            bool operator<=(const Iterator &rhs) const
            {
                return index <= rhs.index;
            }

            bool operator>=(const Iterator &rhs) const
            {
                return index >= rhs.index;
            }

            const it_value_type operator*() const
            {
                return {index, container.ref_get(index)};
            }

            it_value_type operator*()
            {
                return {index, container.ref_get(index)};
            }

            operator bool() const
            {
                return index_valid() && value_valid();
            }

            bool index_valid() const
            {
                return index < container.end().get_index();
            }

            bool value_valid() const
            {
                return index_valid() && container.contains(index);
            }

            size_type_t get_index() const
            {
                return index;
            }
        };

        // Returns an iterator to the first element in the array
        // This iterator is not thread safe as it takes a reference to the array
        // If the array is modified while the iterator is being used, the behavior is undefined
        // If you want to use it make sure to that nobody can modify the array while the iterator is being used
        Iterator begin()
        {
            return Iterator(*this, 0);
        }

        // Returns an iterator to the element following the last element in the array
        // This iterator is not thread safe as it takes a reference to the array
        // If the array is modified while the iterator is being used, the behavior is undefined
        // If you want to use it make sure to that nobody can modify the array while the iterator is being used
        Iterator end()
        {
            return Iterator(*this, m_biggest_used_index + 1);
        }
    };

    // Async queue
    template <typename T>
    class async_queue
    {
    private:
        mutex m_mutex;
        condition_variable m_condition;
        queue<T> m_queue;

    public:
        async_queue() = default;
        ~async_queue() = default;

        bool empty() const
        {
            unique_lock<mutex> lock(m_mutex);
            return m_queue.empty();
        }

        void push(const T &value)
        {
            {
                unique_lock<mutex> lock(m_mutex);
                m_queue.push(value);
            }
            m_condition.notify_one();
        }

        void push(T &&value)
        {
            {
                unique_lock<mutex> lock(m_mutex);
                m_queue.push(std::move(value));
            }
            m_condition.notify_one();
        }

        template <typename... Args>
        void emplace(Args &&...args)
        {
            {
                unique_lock<mutex> lock(m_mutex);
                m_queue.emplace(std::forward<Args>(args)...);
            }
            m_condition.notify_one();
        }

        T pop()
        {
            unique_lock<mutex> lock(m_mutex);
            m_condition.wait(lock, [this]
                             { return !m_queue.empty(); });
            T value = move(m_queue.front());
            m_queue.pop();
            return value;
        }

        bool poll(T &value)
        {
            unique_lock<mutex> lock(m_mutex);
            if (m_queue.empty())
            {
                return false;
            }
            value = std::move(m_queue.front());
            m_queue.pop();
            return true;
        }

        void clear()
        {
            unique_lock<mutex> lock(m_mutex);
            while (!m_queue.empty())
            {
                m_queue.pop();
            }
        }

        size_t size() const
        {
            unique_lock<mutex> lock(m_mutex);
            return m_queue.size();
        }
    };

    template <typename T>
    class async_list
    {
    private:
        mutable mutex m_mutex;
        list<T> m_list;

    public:
        void push_back(const T &value)
        {
            unique_lock<mutex> lock(m_mutex);
            m_list.push_back(value);
        }

        void push_back(T &&value)
        {
            unique_lock<mutex> lock(m_mutex);
            m_list.push_back(std::move(value));
        }

        template <typename... Args>
        void emplace_back(Args &&...args)
        {
            unique_lock<mutex> lock(m_mutex);
            m_list.emplace_back(std::forward<Args>(args)...);
        }

        void clear()
        {
            unique_lock<mutex> lock(m_mutex);
            m_list.clear();
        }

        bool empty() const
        {
            unique_lock<mutex> lock(m_mutex);
            return m_list.empty();
        }

        void remove_if(function<bool(const T &)> predicate, function<void(T &)> on_remove = [](T &) {})
        {
            unique_lock<mutex> lock(m_mutex);
            for (auto it = m_list.begin(); it != m_list.end();)
            {
                if (predicate(*it))
                {
                    on_remove(*it);
                    it = m_list.erase(it);
                }
                else
                {
                    ++it;
                }
            }
        }
    };

    // Thread queue
    class thread_list
    {
    private:
        async_list<thread> m_threads;
        async_queue<thread::id> m_ids;

    public:
        thread_list() = default;

        template <typename F, typename... Args>
        void push(F &&f, Args &&...args)
        {
            m_threads.emplace_back([this](F &&f, Args &&...args)
                                   {
                    thread::id id = this_thread::get_id();
                    f(std::forward<Args>(args)...);
                    m_ids.push(id); }, std::forward<F>(f), std::forward<Args>(args)...);
        }

        void join()
        {
            m_threads.remove_if([](const thread &t)
                                { return t.joinable(); },
                                [](thread &t)
                                { t.join(); });
            m_threads.clear();
            m_ids.clear();
        }

        void update()
        {
            thread::id id;
            while (m_ids.poll(id))
            {
                m_threads.remove_if([id](const thread &t)
                                    { return t.get_id() == id; },
                                    [](thread &t)
                                    { t.join(); });
            }
        }

        void clear()
        {
            join();
            m_threads.clear();
            m_ids.clear();
        }

        bool empty() const
        {
            return m_threads.empty();
        }

        ~thread_list()
        {
            clear();
        }
    };

    class async_thread_pool
    {
    private:
        thread_list m_threads;
        atomic<bool> m_stop;
        atomic<bool> m_has_event;
        thread m_thread;
        condition_variable m_condition;
        mutex m_mutex;

    public:
        async_thread_pool()
        {
            m_stop = false;
            m_has_event = false;
            m_thread = thread([this]()
                              {
                do {
                    m_threads.update();
                    unique_lock<mutex> lock(m_mutex);
                    m_condition.wait(lock, [this] { return m_stop || m_has_event; });
                    m_has_event = false;
                } while (!m_stop); });
        }

        template <typename F, typename... Args>
        void push(F &&f, Args &&...args)
        {
            m_threads.push(
               [this](F &&f, Args &&...args)
               {
                   f(std::forward<Args>(args)...);
                   m_has_event = true;
                   m_condition.notify_one();
               }, std::forward<F>(f), std::forward<Args>(args)...);
        }

        void clear()
        {
            m_threads.clear();
        }

        bool empty() const
        {
            return m_threads.empty();
        }

        ~async_thread_pool()
        {
            m_stop = true;
            m_condition.notify_one();
            m_thread.join();
        }
    };

    using byte = uint8_t;

    class type_checker
    {
    public:
        template <typename T>
        static constexpr bool is_arithmetic_type()
        {
            return std::is_arithmetic_v<T>;
        }

        template <typename T>
        static constexpr bool is_arithmetic_type(const T &)
        {
            return is_arithmetic_type<T>();
        }

        template <typename T>
        static constexpr bool is_enum_type()
        {
            return std::is_enum_v<T>;
        }

        template <typename T>
        static constexpr bool is_enum_type(const T &)
        {
            return is_enum_type<T>();
        }

        template <typename T>
        static constexpr bool is_string_type()
        {
            return std::is_same_v<std::remove_cvref_t<T>, std::string>;
        }

        template <typename T>
        static constexpr bool is_string_type(const T &)
        {
            return is_string_type<T>();
        }

        template <typename T>
        static constexpr bool is_vector_type()
        {
            return std::is_same_v<std::remove_cvref_t<T>, std::vector<typename T::value_type>>;
        }

        template <typename T>
        static constexpr bool is_vector_type(const T &)
        {
            return is_vector_type<T>();
        }

        template <typename T>
        static constexpr bool is_byte_type()
        {
            return std::is_same_v<std::remove_cvref_t<T>, byte>;
        }

        template <typename T>
        static constexpr bool is_byte_type(const T &)
        {
            return is_byte_type<T>();
        }

        template <typename T>
        static constexpr bool is_pointer_type()
        {
            return std::is_pointer_v<T>;
        }

        template <typename T>
        static constexpr bool is_pointer_type(const T &)
        {
            return is_pointer_type<T>();
        }
    };

    // A serializer that can be used to serialize data into a byte array
    // It serializes data in little endian format.
    // It can be used to serialize any type of data.
    // When serializing a type, it must either be a byte array, a string, or arithmetical type (int, float, etc.)
    // You cannot serialize any floating points because they are not normalized.

    // When serializing a vector, it will be serialized as:
    //      A uint64_t representing the size of the vector
    //      The data of the vector
    //      All the data is written with the write function so each element
    //          will be normalized as little endian

    // When serializing a string it will be serialized as:
    //      A uint64_t representing the size of the string
    //      The data of the string

    // The byte array will be considered raw data and nothing will be done to
    // indicate the size of the array. It will be written as is.
    class Serializer
    {
    public:
        using size_type_t = size_t;
        using container_t = vector<byte>;
        using slices_t = vector<container_t>;

    private:
        container_t m_data;

        // Writes the data to the byte array
        inline void _write_bytes(const byte *data, size_t size)
        {
            m_data.insert(m_data.end(), data, data + size);
        }

        // Writes a string to the byte array
        inline void _write_string(const string &data)
        {
            uint64_t size = data.size();
            write(size);
            write_bytes(reinterpret_cast<const byte *>(data.data()), size);
        }

        // Writes a vector to the byte array
        template <typename T>
        inline void _write_vector(const vector<T> &data)
        {
            uint64_t size = data.size();
            write(size);
            std::for_each(data.begin(), data.end(), [this](const T &value)
                          { write(value); });
        }

        // Writes an arithmetical type to the byte array
        template <typename T>
        inline void _write_arithmetic(const T &data)
        {
            static_assert(sizeof(T) <= sizeof(byte) * 8, "T is too big to be serialized as a arithmetical type");
            T copy_data = boost::endian::native_to_little(data);
            write_bytes(reinterpret_cast<byte *>(&copy_data), sizeof(T));
        }

    public:
        // Optimizes the memory usage of the byte array
        void reserve(size_type_t size)
        {
            m_data.reserve(size);
        }

        // Writes data to the byte array using the template parameter
        template <typename T>
        inline void write(const T &data)
        {
            if constexpr (type_checker::is_arithmetic_type(data))
            {
                _write_arithmetic(data);
            }
            else if constexpr (type_checker::is_string_type(data))
            {
                _write_string(data);
            }
            else if constexpr (type_checker::is_vector_type(data))
            {
                _write_vector(data);
            }
            else if constexpr (type_checker::is_byte_type(data))
            {
                _write_bytes(&data, sizeof(data));
            }
            else
            {
                static_assert(false, "T is not a valid type to be serialized");
            }
        }

        // write a sequence of raw bytes to the byte array
        inline void write_bytes(const byte *data, size_type_t size)
        {
            _write_bytes(data, size);
        }

        // Returns the byte array
        container_t &bytes()
        {
            return m_data;
        }

        // Returns the byte array (const)
        const container_t &bytes() const
        {
            return m_data;
        }

        // Return an array of byte array that are splitted into slices of size n
        slices_t as_slices_of(size_type_t n) const
        {
            if (n <= 0)
                return {};

            slices_t slices;
            size_type_t i = 0;

            while (i < m_data.size())
            {
                slices.push_back(container_t(m_data.begin() + i, m_data.begin() + std::min(i + n, m_data.size())));
                i += n;
            }
            return slices;
        }

        // Returns the size of the byte array
        size_type_t size() const
        {
            return m_data.size();
        }

        // Clears the byte array
        void clear()
        {
            m_data.clear();
        }

        // Merges two serializers into one
        static Serializer merge(Serializer a, Serializer b)
        {
            Serializer s;
            s.reserve(a.size() + b.size());
            s.write(a.bytes());
            s.write(b.bytes());
            return s;
        }

        // Add a sequence of bytes every N bytes (can exclud/include the given sequence size)
        // including the sequence size means that the sequence size will be added to the N
        // It can be useful for adding headers to a byte array
        slices_t add_sequence_every_n_bytes_and_slice(
            size_type_t n, Serializer sequence,
            bool include_sequence_size = true) const
        {
            const container_t &sbytes = sequence.bytes();
            if (include_sequence_size)
            {
                if (n <= sbytes.size())
                    throw std::invalid_argument("n must be greater than the size of the sequence");
                n -= sbytes.size();
            }

            Serializer s;
            s.reserve(m_data.size() + (m_data.size() / n) * sbytes.size());

            for (size_type_t i = 0; i < m_data.size(); i += n)
            {
                s.write_bytes(m_data.data() + i, std::min(n, m_data.size() - i));
                if (i + n < m_data.size())
                    s.write_bytes(sbytes.data(), sbytes.size());
            }
            return s.as_slices_of(n + (include_sequence_size ? sbytes.size() : 0));
        }

        // Constructor
        Serializer() = default;

        // Destructor
        ~Serializer() = default;
    };

    template <typename T>
    static inline Serializer &operator<<(Serializer &serializer, const T &data)
    {
        serializer.write(data);
        return serializer;
    }

    // A deserializer that can be used to deserialize data from a byte array
    // It deserializes the data the same way it was serialized (c.f. Serializer)
    class Deserializer
    {
    public:
        using size_type_t = size_t;

    private:
        byte *m_data;
        size_type_t m_size;
        byte *m_ptr;
        byte *m_endptr;

        // Reads a sequence of raw bytes for an arithmetical type
        template <typename T>
        T _read_arithmetic()
        {
            static_assert(sizeof(T) <= sizeof(byte) * 8, "T is too big to be deserialized");

            if (m_ptr + sizeof(T) >= m_endptr)
                throw std::runtime_error("Not enough data to deserialize arithmetical type");
            T data;
            std::memcpy(&data, m_ptr, sizeof(T));
            m_ptr += sizeof(T);
            boost::endian::little_to_native_inplace(data);
            return data;
        }

        // Reads a string
        string _read_string()
        {
            size_type_t size = read<size_type_t>();
            if (m_ptr + size >= m_endptr)
                throw std::runtime_error("Not enough data to deserialize string");
            string str(reinterpret_cast<char *>(m_ptr), size);
            m_ptr += size;
            return str;
        }

        // Reads a vector of arithmetical types or strings
        template <typename T>
        vector<T> _read_vector()
        {
            size_type_t size = read<size_type_t>();
            vector<T> vec;
            vec.reserve(size);
            for (size_type_t i = 0; i < size; ++i)
                vec.push_back(read<T>());
            return vec;
        }

        // Reads a sequence of raw bytes
        vector<byte> _read_bytes(size_type_t size)
        {
            if (m_ptr + size >= m_endptr)
                throw std::runtime_error("Not enough data to deserialize bytes");
            vector<byte> vec(m_ptr, m_ptr + size);
            m_ptr += size;
            return vec;
        }

    public:
        // Constructor
        // data: A pointer to the byte array
        // size: The size of the byte array
        Deserializer(byte *data, size_type_t size)
            : m_data(data), m_size(size), m_ptr(data), m_endptr(data + size)
        {
        }

        // Reads data from the byte array
        template <typename T>
        T read()
        {
            if constexpr (type_checker::is_arithmetic_type<T>())
            {
                return _read_arithmetic<T>();
            }
            else if constexpr (type_checker::is_string_type<T>())
            {
                return _read_string();
            }
            else if constexpr (type_checker::is_vector_type<T>())
            {
                return _read_vector<typename T::value_type>();
            }
            else
            {
                static_assert(false, "T is not a valid type to be deserialized");
            }
        }

        // Reads a sequence of raw bytes with a given size
        vector<byte> read_bytes(size_type_t size)
        {
            return _read_bytes(size);
        }
    };

    // Deserialize any T type deserializable by Deserializer::read<T>()
    template <typename T>
    static inline Deserializer &operator>>(Deserializer &deserializer, T &data)
    {
        data = deserializer.read<T>();
        return deserializer;
    }

    class base_client;

    using buffer_t = std::shared_ptr<vector<byte>>;

    static inline buffer_t make_buffer(size_t size)
    {
        return std::make_shared<vector<byte>>(size);
    }

    static inline buffer_t make_buffer(const byte *data, size_t size)
    {
        return std::make_shared<vector<byte>>(data, data + size);
    }

    static inline buffer_t make_buffer(const vector<byte> &data)
    {
        return std::make_shared<vector<byte>>(data);
    }

    static inline buffer_t make_buffer(vector<byte> &&data)
    {
        return std::make_shared<vector<byte>>(std::move(data));
    }

    using shared_base_client = std::shared_ptr<base_client>;

    using client_on_connect_callback = void (*)(shared_base_client);
    using client_on_connect_error_callback = void (*)(shared_base_client, const boost::system::error_code &);
    using client_already_connected_callback = void (*)(shared_base_client);

    using client_on_disconnect_callback = void (*)(shared_base_client);
    using client_already_disconnected_callback = void (*)(shared_base_client);

    using client_on_receive_callback = void (*)(shared_base_client, const buffer_t, const boost::system::error_code &, size_t);
    using client_on_receive_error_callback = void (*)(shared_base_client, const boost::system::error_code &);

    using client_on_send_callback = bool (*)(shared_base_client, buffer_t &);
    using client_on_send_error_callback = void (*)(shared_base_client, const boost::system::error_code &);
    using client_on_send_success = void (*)(shared_base_client, const buffer_t, const boost::system::error_code &, size_t);

    using client_on_specific_error_callback = void (*)(shared_base_client, const string &);

    // base client class
    class base_client : public std::enable_shared_from_this<base_client>
    {
    protected:
        // callbacks
        client_on_connect_callback m_on_connect = nullptr;
        client_on_connect_error_callback m_on_connect_error = nullptr;
        client_already_connected_callback m_already_connected = nullptr;

        client_on_disconnect_callback m_on_disconnect = nullptr;
        client_already_connected_callback m_already_disconnected = nullptr;

        client_on_receive_callback m_on_receive = nullptr;
        client_on_receive_error_callback m_on_receive_error = nullptr;

        client_on_send_callback m_on_send = nullptr;
        client_on_send_error_callback m_on_send_error = nullptr;
        client_on_send_success m_on_send_success = nullptr;

        client_on_specific_error_callback m_on_specific_error = nullptr;

        // callback thread pool
        async_thread_pool m_callback_thread_pool;

        // connection status
        atomic<bool> m_connected;

    public:
        void set_on_connect(client_on_connect_callback callback)
        {
            m_on_connect = callback;
        }

        void set_on_connect_error(client_on_connect_error_callback callback)
        {
            m_on_connect_error = callback;
        }

        void set_already_connected(client_already_connected_callback callback)
        {
            m_already_connected = callback;
        }

        void set_on_disconnect(client_on_disconnect_callback callback)
        {
            m_on_disconnect = callback;
        }

        void set_already_disconnected(client_already_connected_callback callback)
        {
            m_already_disconnected = callback;
        }

        void set_on_receive(client_on_receive_callback callback)
        {
            m_on_receive = callback;
        }

        void set_on_receive_error(client_on_receive_error_callback callback)
        {
            m_on_receive_error = callback;
        }

        void set_on_send(client_on_send_callback callback)
        {
            m_on_send = callback;
        }

        void set_on_send_error(client_on_send_error_callback callback)
        {
            m_on_send_error = callback;
        }

        void set_on_send_success(client_on_send_success callback)
        {
            m_on_send_success = callback;
        }

        void set_on_specific_error(client_on_specific_error_callback callback)
        {
            m_on_specific_error = callback;
        }

        static constexpr size_t default_receive_buffer_size = 1024;

    private:
        buffer_t m_receive_buffer;

    public:
        base_client()
        {
            m_receive_buffer = make_buffer(default_receive_buffer_size);
            m_connected = false;
        }

        virtual ~base_client() = default;

        bool connected() const
        {
            return m_connected;
        }

        buffer_t &receive_buffer()
        {
            return m_receive_buffer;
        }

        const buffer_t &receive_buffer() const
        {
            return m_receive_buffer;
        }

        buffer_t &receive_buffer(size_t size)
        {
            m_receive_buffer->resize(size);
            return m_receive_buffer;
        }

        shared_base_client as_shared()
        {
            return shared_from_this();
        }

        bool callbacks_are_valid()
        {
            void *callbacks[] = {
                (void*)m_on_connect,
                (void*)m_on_connect_error,
                (void*)m_already_connected,
                (void*)m_on_disconnect,
                (void*)m_already_disconnected,
                (void*)m_on_receive,
                (void*)m_on_receive_error,
                (void*)m_on_send,
                (void*)m_on_send_error,
                (void*)m_on_send_success,
                (void*)m_on_specific_error
            };

            for (void *callback : callbacks)
            {
                if (callback == nullptr)
                {
                    return false;
                }
            }
            return true;
        }

        virtual bool connect(const string &ip, const uint16_t &port) = 0;
        virtual bool disconnect() = 0;
        virtual bool send(buffer_t &buffer) = 0;
    };

    // TCP client class
    class base_tcp_client : public base_client
    {
    private:
        struct base_tcp_client_connection_data
        {
            boost::asio::ip::tcp::resolver m_resolver;
            boost::asio::ip::tcp::resolver::query m_query;
            boost::asio::ip::tcp::resolver::iterator m_endpoint_iterator;
            boost::asio::ip::tcp::socket m_socket;
            boost::asio::io_service m_io_service;
            thread m_io_service_thread;

            base_tcp_client_connection_data(const string &ip, const uint16_t &port)
                : m_resolver(m_io_service), m_query(ip, "daytime"), m_endpoint_iterator(m_resolver.resolve(m_query)), m_socket(m_io_service)
            {
            }
        };

        std::shared_ptr<base_tcp_client_connection_data> m_connection_data;
        buffer_t m_receive_buffer;

        void start_reading()
        {
            if (!m_connected)
            {
                return;
            }

            auto client = this->as_shared();

            m_connection_data->m_socket.async_receive(
                boost::asio::buffer(*m_receive_buffer),
                [this, client, recv_buffer = m_receive_buffer](const boost::system::error_code &ec, size_t bytes_transferred)
                {
                    if (ec)
                    {
                        this->m_callback_thread_pool.push(
                            [this, client, ec]()
                            { this->m_on_receive_error(client, ec); });
                        return;
                    }

                    auto buffer_cpy = make_buffer(*recv_buffer);

                    m_callback_thread_pool.push(
                        [this, client, buffer_cpy, ec, bytes_transferred]()
                        { this->m_on_receive(client, buffer_cpy, ec, bytes_transferred); }
                    );
                }
            );
        }

    public:
        base_tcp_client() = default;

        virtual ~base_tcp_client() = default;

        virtual bool connect(const string &ip, const uint16_t &port) override
        {
            assert(callbacks_are_valid());

            auto client = this->as_shared();

            const auto already_connected_callback =
                [this, client]()
            { this->m_already_connected(client); };

            const auto on_connect_error_callback =
                [this, client](const boost::system::error_code &ec)
            { this->m_on_connect_error(client, ec); };

            const auto on_connect_callback =
                [this, client]()
            {
                this->m_on_connect(client);
                this->start_reading();
            };

            const auto io_service_launch = [this]()
            {
                this->m_connection_data->m_io_service.run();
            };

            if (m_connected)
            {
                m_callback_thread_pool.push(already_connected_callback);
                return false;
            }

            m_connection_data = std::make_shared<base_tcp_client_connection_data>(ip, port);

            boost::system::error_code error;
            boost::asio::ip::tcp::resolver::iterator end;

            while (error && m_connection_data->m_endpoint_iterator != end)
            {
                m_connection_data->m_socket.close();
                m_connection_data->m_socket.connect(*m_connection_data->m_endpoint_iterator++, error);
            }

            if (error)
            {
                m_callback_thread_pool.push(on_connect_error_callback, error);
                return false;
            }

            m_connected = true;
            m_connection_data->m_io_service_thread = thread(io_service_launch);
            m_callback_thread_pool.push(on_connect_callback);
            return true;
        }

        virtual bool disconnect() override
        {
            auto client = this->as_shared();

            const auto disconnect_callback =
                [this, client]()
            { this->m_on_disconnect(client); };
            const auto already_disconnected_callback =
                [this, client]()
            { this->m_already_disconnected(client); };

            if (!m_connected)
            {
                m_callback_thread_pool.push(already_disconnected_callback);
                return false;
            }
            m_connected = false;
            m_connection_data->m_socket.close();
            m_connection_data->m_io_service.stop();
            m_connection_data->m_io_service_thread.join();
            m_connection_data = nullptr;
            m_callback_thread_pool.push(disconnect_callback);
            return true;
        }

        virtual bool send(buffer_t &buffer) override
        {
            if (!m_connected)
            {
                return false;
            }

            auto client = this->as_shared();

            const auto asio_send_callback =
                [this, client, buffer](const boost::system::error_code &ec, size_t bytes_transferred)
            {
                const auto on_error = [this, client, ec]()
                {
                    this->m_on_send_error(client, ec);
                };

                const auto on_success = [this, client, buffer, ec, bytes_transferred]()
                {
                    this->m_on_send_success(client, buffer, ec, bytes_transferred);
                };

                if (ec)
                {
                    m_callback_thread_pool.push(on_error);
                }
                else
                {
                    m_callback_thread_pool.push(on_success);
                }
            };

            const auto operation_canceled_callback =
                [this, client]()
            {
                this->m_on_send_error(client, boost::system::errc::make_error_code(boost::system::errc::operation_canceled));
            };

            if (this->m_on_send(client, buffer))
            {
                m_connection_data->m_socket.async_send(
                    boost::asio::buffer(*buffer),
                    asio_send_callback
                );
            }
            else
            {
                m_callback_thread_pool.push(operation_canceled_callback);
            }
            return true;
        }
    };
}
