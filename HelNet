#pragma once

#include <boost/asio.hpp>
#include <boost/endian/conversion.hpp>
#include <boost/system/error_code.hpp>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <memory>
#include <utility>
#include <chrono>
#include <optional>
#include <vector>
#include <atomic>
#include <algorithm>
#include <list>
#include <thread>

#include <iostream>

namespace hl
{
namespace net
{
    // Thread queue
    class thread_list
    {
    private:
        std::list<std::thread> m_threads;
        std::queue<std::thread::id> m_ids; // all the current threads ids that are done
        mutable std::mutex m_mutex;

        // Optionally get updates on the events
        std::condition_variable* m_condition;

    public:
        thread_list() 
            : m_condition(nullptr) {}
        thread_list(std::condition_variable &condition) : m_condition(&condition) {}

        template <typename F, typename... Args>
        void push(F &&f, Args &&...args)
        {
            m_threads.emplace_back([this](F &&f, Args &&...args) { 
                f(std::forward<Args>(args)...);
                std::unique_lock<std::mutex> lock(m_mutex);
                lock.lock();
                m_ids.push(std::this_thread::get_id());

                // Updates when one of the threads is done if the condition variable is set
                if (m_condition)
                {
                    m_condition->notify_one();
                }
            }, std::forward<F>(f), std::forward<Args>(args)...);
        }

        void join()
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            for (auto &t : m_threads)
            {
                t.join();
            }
            m_ids = std::queue<std::thread::id>(); // clear the ids
            m_threads.clear();
        }

        void update()
        {
            // iterate through the ids and remove the threads that are done
            std::lock_guard<std::mutex> lock(m_mutex);
            while (!m_ids.empty())
            {
                auto id = m_ids.front();
                m_ids.pop();
                m_threads.remove_if([id](const std::thread &t) { return t.get_id() == id; });
            }
        }

        bool empty() const
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            return m_threads.empty();
        }

        ~thread_list()
        {
            join();
        }
    };

    class async_thread_pool
    {
    private:
        std::atomic_bool m_stop;
        std::atomic_bool m_has_event;
        std::condition_variable m_condition;
        std::mutex m_mutex;

        std::thread m_async_thread_pool_update_thread;
        thread_list m_thread_list;

    public:
        async_thread_pool()
            : m_stop(false), m_has_event(false), m_thread_list(m_condition)
        {
            m_async_thread_pool_update_thread = std::thread([this]() {
                do {
                    m_thread_list.update();
                    std::unique_lock<std::mutex> lock(m_mutex);
                    m_condition.wait(lock, [this] { return m_stop || m_has_event; });
                    m_has_event = false;
                } while (!m_stop);
            });
        }

        template <typename F, typename... Args>
        void push(F &&f, Args &&...args)
        {
            if (m_stop)
            {
                return; // Ignore silently (Here just in case of Race condition)
            }

            m_thread_list.push(
               [this](F &&f, Args &&...args)
               {
                   f(std::forward<Args>(args)...);
                   m_has_event = true;
                   m_condition.notify_one();
               }, std::forward<F>(f), std::forward<Args>(args)...);
        }

        void clear()
        {
            m_thread_list.join();
            m_condition.notify_one();
        }

        bool empty() const
        {
            return m_thread_list.empty();
        }

        ~async_thread_pool()
        {
            m_stop = true;
            clear();
        }
    };

    using byte = uint8_t;

    using buffer_t = std::vector<byte>;
    using shared_buffer_t = std::shared_ptr<buffer_t>;

    static inline shared_buffer_t make_shared_buffer(size_t size)
    {
        return std::make_shared<std::vector<byte>>(size);
    }

    static inline shared_buffer_t make_shared_buffer(const byte *data, size_t size)
    {
        return std::make_shared<std::vector<byte>>(data, data + size);
    }

    static inline shared_buffer_t make_shared_buffer(const std::vector<byte> &data)
    {
        return std::make_shared<std::vector<byte>>(data);
    }

    static inline shared_buffer_t make_shared_buffer(std::vector<byte> &&data)
    {
        return std::make_shared<std::vector<byte>>(std::move(data));
    }

    static inline shared_buffer_t make_shared_buffer(const shared_buffer_t &data)
    {
        return std::make_shared<std::vector<byte>>(*data);
    }

    class base_abstract_client;

    using client_on_connect_callback            = std::function<void(base_abstract_client& client)>;
    using client_on_connect_error_callback      = std::function<void(base_abstract_client& client, const boost::system::error_code& ec)>;
    using client_already_connected_callback     = std::function<void(base_abstract_client& client)>;

    using client_on_disconnect_callback         = std::function<void(base_abstract_client& client)>;
    using client_already_disconnected_callback  = std::function<void(base_abstract_client& client)>;

    // on_receive_* sends a copy of the buffer
    using client_on_receive_callback            = std::function<void(base_abstract_client& client, buffer_t& buffer_copy, const size_t& recv_bytes)>;
    using client_on_receive_error_callback      = std::function<void(base_abstract_client& client, buffer_t& buffer_copy, const boost::system::error_code& ec, const size_t& recv_bytes)>;

    // The buffer used in on_send_* is the same buffer that is sent
    // This means that the buffer is not copied but sent as a reference
    // Please keep this in mind
    using client_on_send_callback               = std::function<bool(base_abstract_client& client, buffer_t& buffer_copy)>;
    using client_on_send_error_callback         = std::function<void(base_abstract_client& client, const buffer_t& buffer_copy, const boost::system::error_code& ec, const size_t& sent_bytes)>;
    using client_on_send_success                = std::function<void(base_abstract_client& client, const buffer_t& buffer_copy, const boost::system::error_code& ec, const size_t& sent_bytes)>;

    using shared_base_abstract_client = std::shared_ptr<base_abstract_client>;

    // base client class
    class base_abstract_client : public std::enable_shared_from_this<base_abstract_client>
    {
    protected:
        // callbacks
        client_on_connect_callback m_on_connect = nullptr;
        client_on_connect_error_callback m_on_connect_error = nullptr;
        client_already_connected_callback m_already_connected = nullptr;

        client_on_disconnect_callback m_on_disconnect = nullptr;
        client_already_connected_callback m_already_disconnected = nullptr;

        client_on_receive_callback m_on_receive = nullptr;
        client_on_receive_error_callback m_on_receive_error = nullptr;

        client_on_send_callback m_on_send = nullptr;
        client_on_send_error_callback m_on_send_error = nullptr;
        client_on_send_success m_on_send_success = nullptr;

        // callback thread pool
        async_thread_pool m_callback_thread_pool;

        // connection status
        std::atomic_bool m_connected;

    public:
        void set_on_connect(const client_on_connect_callback &callback)
        {
            m_on_connect = callback;
        }

        void set_on_connect_error(const client_on_connect_error_callback &callback)
        {
            m_on_connect_error = callback;
        }

        void set_already_connected(const client_already_connected_callback &callback)
        {
            m_already_connected = callback;
        }

        void set_on_disconnect(const client_on_disconnect_callback &callback)
        {
            m_on_disconnect = callback;
        }

        void set_already_disconnected(const client_already_connected_callback &callback)
        {
            m_already_disconnected = callback;
        }

        void set_on_receive(const client_on_receive_callback &callback)
        {
            m_on_receive = callback;
        }

        void set_on_receive_error(const client_on_receive_error_callback &callback)
        {
            m_on_receive_error = callback;
        }

        void set_on_send(const client_on_send_callback &callback)
        {
            m_on_send = callback;
        }

        void set_on_send_error(const client_on_send_error_callback &callback)
        {
            m_on_send_error = callback;
        }

        void set_on_send_success(const client_on_send_success &callback)
        {
            m_on_send_success = callback;
        }

        static constexpr size_t default_receive_buffer_size = 1024;

    private:
        shared_buffer_t m_receive_buffer;

    public:
        base_abstract_client()
        {
            m_receive_buffer = make_shared_buffer(default_receive_buffer_size);
            m_connected = false;
        }

        virtual ~base_abstract_client() = default;

        bool connected() const
        {
            return m_connected;
        }

        shared_buffer_t &receive_buffer()
        {
            return m_receive_buffer;
        }

        const shared_buffer_t &receive_buffer() const
        {
            return m_receive_buffer;
        }

        shared_base_abstract_client as_shared()
        {
            return shared_from_this();
        }

        bool callbacks_are_non_null()
        {
            return m_on_connect &&
                m_on_connect_error &&
                m_already_connected &&
                m_on_disconnect &&
                m_already_disconnected &&
                m_on_receive &&
                m_on_receive_error &&
                m_on_send &&
                m_on_send_error &&
                m_on_send_success;
        }

        virtual bool connect(const std::string &ip, const uint16_t &port, const std::string& query_resolver_protocol) = 0;
        virtual bool disconnect() = 0;
        virtual bool send(shared_buffer_t &buffer) = 0;
    };

    // TCP client class
    template<class Protocol>
    class base_client : public base_abstract_client
    {
    public:
        struct connection_data 
        {
            typename Protocol::resolver m_resolver;
            typename Protocol::resolver::query m_query;
            typename Protocol::resolver::iterator m_endpoint_iterator;
            typename Protocol::socket m_socket;
            boost::asio::io_service m_io_service;
            std::thread m_io_service_thread;

            connection_data(const std::string &ip, const uint16_t &port, const std::string &resolver_query)
                : m_resolver(m_io_service)
                , m_query(ip, resolver_query)
                , m_endpoint_iterator(m_resolver.resolve(m_query))
                , m_socket(m_io_service)
            {
            }
        };
    
    private:
        using base_abstract_client::m_on_connect;
        using base_abstract_client::m_on_connect_error;
        using base_abstract_client::m_already_connected;
        using base_abstract_client::m_on_disconnect;
        using base_abstract_client::m_already_disconnected;
        using base_abstract_client::m_on_receive;
        using base_abstract_client::m_on_receive_error;
        using base_abstract_client::m_on_send;
        using base_abstract_client::m_on_send_error;
        using base_abstract_client::m_on_send_success;

    private:

        std::shared_ptr<connection_data> m_connection_data;

        void _start_reading()
        {
            if (!m_connected)
            {
                return;
            }

            auto client = this->as_shared();
            auto recv_buffer = this->receive_buffer();

            m_connection_data->m_socket.async_receive(
                boost::asio::buffer(*recv_buffer),
                [this, client, recv_buffer](const boost::system::error_code &ec, size_t bytes_transferred)
                {
                    auto buffer_cpy = make_shared_buffer(*recv_buffer);

                    if (ec)
                    {
                        this->m_callback_thread_pool.push(
                            [this, client, buffer_cpy, ec, bytes_transferred]()
                            { this->m_on_receive_error(*client, *buffer_cpy, ec, bytes_transferred); });
                        return;
                    }

                    m_callback_thread_pool.push(
                        [this, client, buffer_cpy, bytes_transferred]()
                        { this->m_on_receive(*client, *buffer_cpy, bytes_transferred); }
                    );
                }
            );
        }

    public:
        base_client()
        {
            set_on_connect([](base_abstract_client& client) {
                std::cout << "Default on_connect for client: " << &client << std::endl;
            });

            set_on_connect_error([](base_abstract_client& client, const boost::system::error_code &ec) {
                std::cout << "Default on_connect_error for client: " << &client << " with error: " << ec.message() << std::endl;
            });

            set_already_connected([](base_abstract_client& client) {
                std::cout << "Default already_connected for client: " << &client << std::endl;
            });

            set_on_disconnect([](base_abstract_client& client) {
                std::cout << "Default on_disconnect for client: " << &client << std::endl;
            });

            set_already_disconnected([](base_abstract_client& client) {
                std::cout << "Default already_disconnected for client: " << &client << std::endl;
            });

            set_on_receive([](base_abstract_client& client, const buffer_t &buffer, const size_t &bytes_transferred) {
                std::cout << "Default on_receive for client: " << &client << " with " << bytes_transferred << " bytes" << std::endl;
            });

            set_on_receive_error([](base_abstract_client& client, const buffer_t &buffer, const boost::system::error_code &ec, const size_t &bytes_transferred) {
                std::cout << "Default on_receive_error for client: " << &client << " with error: " << ec.message() << std::endl;
            });

            set_on_send([](base_abstract_client& client, const buffer_t &buffer) {
                std::cout << "Default on_send for client: " << &client << std::endl;
                return true;
            });

            set_on_send_error([](base_abstract_client& client, const buffer_t &buffer, const boost::system::error_code &ec, const size_t& bytes_transferred) {
                std::cout << "Default on_send_error for client: " << &client << " with error: " << ec.message() << std::endl;
            });

            set_on_send_success([](base_abstract_client& client, const buffer_t &buffer, const boost::system::error_code &ec, const size_t& bytes_transferred) {
                std::cout << "Default on_send_success for client: " << &client << " with " << bytes_transferred << " bytes" << std::endl;
            });
        }

        virtual ~base_client() = default;

        virtual bool connect(const std::string &ip, const uint16_t &port, const std::string& query_resolver_protocol="daytime") override
        {
            assert(callbacks_are_non_null());

            auto client = this->as_shared();

            if (m_connected)
            {
                m_callback_thread_pool.push([this, client]()
                {
                    this->m_already_connected(*client);
                });
                return true;
            }

            m_connection_data = std::make_shared<connection_data>(ip, port, query_resolver_protocol);

            boost::system::error_code error;
            boost::asio::ip::tcp::resolver::iterator end;

            while (error && m_connection_data->m_endpoint_iterator != end)
            {
                m_connection_data->m_socket.close();
                m_connection_data->m_socket.connect(*m_connection_data->m_endpoint_iterator++, error);
            }

            if (error)
            {
                const auto on_connect_error_callback = [this, client, ec=error]()
                {
                    this->m_on_connect_error(*client, ec);
                };
                m_callback_thread_pool.push(on_connect_error_callback);
                return false;
            }

            m_connected = true;

            m_connection_data->m_io_service_thread = std::thread([this]()
            {
                this->m_connection_data->m_io_service.run();
            });

            m_callback_thread_pool.push([this, client]()
            {
                this->m_on_connect(*client);
                this->_start_reading();
            });
            return true;
        }

        virtual bool disconnect() override
        {
            auto client = this->as_shared();

            if (!m_connected)
            {
                m_callback_thread_pool.push([this, client]()
                {
                    this->m_already_disconnected(*client);
                });
                return false;
            }

            m_connected = false;
            m_connection_data->m_socket.close();
            m_connection_data->m_io_service.stop();
            m_connection_data->m_io_service_thread.join();
            m_connection_data = nullptr;

            m_callback_thread_pool.push([this, client]()
            {
                this->m_on_disconnect(*client);
            });

            return true;
        }

        virtual bool send(shared_buffer_t &buffer) override
        {
            if (!m_connected)
            {
                return false;
            }

            auto client = this->as_shared();

            if (!this->m_on_send(*client, *buffer))
            {
                m_callback_thread_pool.push([this, client, buffer]() {
                    const static auto ec = boost::system::errc::make_error_code(boost::system::errc::operation_canceled);
                    this->m_on_send_error(*client, *buffer, ec, 0);
                });
            }

            const auto asio_send_callback = [this, client, buffer](const boost::system::error_code &ec, size_t bytes_transferred)
            {
                if (ec)
                {
                    m_callback_thread_pool.push([this, client, buffer, ec, bytes_transferred]()
                    {
                        this->m_on_send_error(*client, *buffer, ec, bytes_transferred);
                    });
                }
                else
                {
                    m_callback_thread_pool.push([this, client, buffer, ec, bytes_transferred]()
                    {
                        this->m_on_send_success(*client, *buffer, ec, bytes_transferred);
                    });
                }
            };

            m_connection_data->m_socket.async_send(
                boost::asio::buffer(*buffer), asio_send_callback
            );

            return true;
        }
    };

    using tcp_client = base_client<boost::asio::ip::tcp>;
    using udp_client = base_client<boost::asio::ip::udp>;
}
}
